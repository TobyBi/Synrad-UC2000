<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>uc2000 API documentation</title>
<meta name="description" content="Synrad UC2000 Controller â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uc2000</code></h1>
</header>
<section id="section-intro">
<h1 id="synrad-uc2000-controller">Synrad UC2000 Controller</h1>
<p>Wrapper to communicate with a Synrad <a href="https://synrad.com/en/products/accessories/uc-2000">UC-2000 Universal Laser Controller</a> through the REMOTE port. A UC-2000 controller controls Synrad <a href="https://synrad.com/en/products/lasers/48-series">48 Series CO<sub>2</sub> lasers</a>.</p>
<h2 id="requirements">Requirements</h2>
<ul>
<li>Python &gt;= 3.8.5</li>
<li>[OPTIONAL] If using <code>Synrad-UC2000</code> with a LabJack, then the <code>LabJack-DAQ</code> module is required. Please visit the <a href="https://github.com/TobyBi/LabJack-DAQ">repository</a> for further installation guidelines.</li>
</ul>
<p>Only written and tested with LabJack DAQ control and 48-2 and 48-5 lasers in mind.</p>
<h2 id="installation">Installation</h2>
<p>To install simply clone the git directory using the following commands:</p>
<pre><code class="language-bash">git clone https://github.com/TobyBi/Synrad-UC2000
</code></pre>
<p>and then move the file <code>uc2000.py</code> to your program location.</p>
<h2 id="todo">TODO</h2>
<ul>
<li>Lua scripting for better timings</li>
<li>Default to PySerial without any DAQ</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ./README.md
&#34;&#34;&#34;

import time

# =============================================================================
# Parameters for UC2000 object
# =============================================================================

_PERCENT_TRANSFORMS =    {63: 62.5}
# Transforming PWM percent incompatible without checksum to compatible ones
SHOT_TIME_RANGE =       [50, 10000]
&#34;&#34;&#34;Valid shot time range.&#34;&#34;&#34;
MIN_LASE_PERCENT =      2
&#34;&#34;&#34;Minimum percent required for laser to be considered OFF to material without
turning the Command signal OFF.&#34;&#34;&#34;

class UC2000Controller:
    &#34;&#34;&#34;
    An interface to SYNRAD 48 series CO2 lasers through UC-2000 controller.

    Communication to the UC-2000 controller from a host using REMOTE
    settings are facilitated through the Serial RS-232 protocol and port.

    Parameters
    ----------
    model : {25, 50}
        SYNRAD 48 series laser model number, indicates the maximum
        optical power output.
    open_labjack : LabJack object
        A LabJack object to transmit messages to the UC-2000,
        by default ``False``.

    Attributes
    ----------
    PARAMETER_NAME_hist : list
        Entire history of previous PARAMETER_NAME from instantiation.

    Notes
    -----
    Pins 2, 3, and 5 of a serial port are used for receive, transmit, and
    ground respectively.
    The host serial port configuration must be
        Baud rate       9600
        Data bits       8 bits
        Parity          None
        Stop bits       1 bit
        Flow control    None

    For further details please refer to:
    https://synrad.com/en/products/accessories/uc-2000

    `uc2000.Message`s are sent to the UC-2000 from the host via a DAQ, in this case
    a LabJack T4/T7 is used. However, any source that can produce RS-232
    asynchronous communication can be used. If a Labjack object or no other
    DAQ is provided then the UC-2000 only stores messages.

    TODO: LUA scripting - call script to improve timings
    TODO: gate pull-up/down, SYNRAD doesn&#39;t know whether gate or comamnd signal activate lasing is faster. Trial and error?

    TODO: receiving communication from the labjack... or using the UC2000 response
        if check_ack:
            daq_response = daq_stats[&#34;response&#34;]

            if not isinstance(daq_response, list):
                daq_response = [daq_response]

            if UC2000_RESPONSE[&#34;ack&#34;] in daq_response:
                self.laser_controller.set_any(setting, option)
                gui_message = &#34;\&#34;{0}\&#34; has changed to \&#34;{1}\&#34;&#34;.format(setting, option)
                action = &#34;continue&#34;
                outcome = option
            elif UC2000_RESPONSE[&#34;nak&#34;] in daq_response:
                gui_message = &#34;\&#34;{0}\&#34; remains unchanged as {1} because UC2000 didn&#39;t accept the message&#34;.format(setting, prev)
                action = &#34;previous&#34;
                outcome = prev
            else:
                gui_message = &#34;Setting \&#34;{0}\&#34; remains unchanged as {1} because there has been no response from UC2000&#34;.format(setting, prev)
                action = &#34;previous&#34;
                outcome = prev
        else:
            self.laser_controller.set_any(setting, option)
            gui_message = &#34;Setting \&#34;{0}\&#34; has changed to \&#34;{1}\&#34;&#34;.format(setting, option)
            action = &#34;continue&#34;
            outcome = option

    TODO: test with slightly longer wait time between asynch communications
    TODO: can send remote status byte inbetween start and end transmission byte of any other
    command - maybe use to check option on laser

    Examples
    --------
    &gt;&gt;&gt; laser = UC2000Controller(model=25)
    &gt;&gt;&gt; with laser:
    ...     laser.percent = 20
    ...     laser.lase = True
    ...     laser.percent = 0
    ...     laser.lase = False

    Demonstration of the .percent and .lase commands
    &#34;&#34;&#34;

    percent_step = 0.5
    &#34;&#34;&#34;Minimum step size of PWM percent.&#34;&#34;&#34;

    _default = {
        &#34;pwm_freq&#34;:         20,   # Higher PWM frequency means lower ripple in optical beam response
        &#34;gate_logic&#34;:       &#34;up&#34;,
        &#34;max_pwm&#34;:          95,
        &#34;lase_on_power_up&#34;: False,
        &#34;mode&#34;:             &#34;manual&#34;, # this will be different for reflow and laser machining
        &#34;lase&#34;:             False,
        &#34;percent&#34;:          0,
    }
    # TODO: update RC params style?
    # TODO: set defaults list into controller as argument for changable settings

    def __init__(self, model: int, open_labjack=False):
        &#34;&#34;&#34;Inits a UC2000 object.&#34;&#34;&#34;
        self.model = model

        self._open_labjack = open_labjack

        self.pwm_freq_hist = [None]
        self.gate_logic_hist = [None]
        self.max_pwm_hist = [None]
        self.lase_on_power_up_hist = [None]
        self.mode_hist = [None]
        self.lase_hist = [None]
        self.percent_hist = [None]
        self.checksum_hist = []
        self.shot_time_hist = []

        # Assumes that Checksum mode is enabled...
        # and why would we not use checksum mode anyways
        self.checksum = True

        self.reset()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        if exc_type is KeyboardInterrupt:
            print(&#34;Laser process stopped by user&#34;)
            self.percent = 0
            self.lase = False
            # returning False because we want to allow nested with statements
            # above the stack to also use their __exit__ which turns the laser
            # off and low set percent.
            return False

        # turn it down anyways
        self.percent = 0
        self.lase = False
        return exc_type is None

    @property
    def lase(self):
        &#34;&#34;&#34;Return lase state.&#34;&#34;&#34;
        return self._lase

    @lase.setter
    def lase(self, state: bool):
        &#34;&#34;&#34;
        Set lase state to either True or False.

        Parameters
        ----------
        state : bool
            New set lase state.

        Notes
        -----
        Lase state is controlled by a Command signal for LOW (0 - 0.5V DC)
        and HIGH (3.5 - 5V DC).

        When the Command signal is low for &gt;200us, the UC-2000 always supplies
        laser with 5kHz, 1us tickle pulse that pre-ionises the laser gas to
        just below lasing threshold. Any increase in pulse width causes
        emission as enough energy is added to the plasma.

        If a labjack is connected, then a LASE message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._lase = state
        self.lase_hist.append(state)

        # if the new option is the same as before don&#39;t send changes to labjack
        if (self.lase_hist[-2] != state) and self._open_labjack:
            msg = Message(&#34;lase&#34;, state, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def percent(self):
        &#34;&#34;&#34;Return laser percent, representing the PWM signal duty cycle percentage.&#34;&#34;&#34;
        return self._percent

    @percent.setter
    def percent(self, per: float):
        &#34;&#34;&#34;
        Set laser percent (PWM signal duty cycle percentage), limited to
        between 0 and 95/99% in steps of 0.5%.

        Parameters
        ----------
        per : float
            New PWM duty cycle percentage, in seteps of 0.5%

        Notes
        -----
        The laser percent defaults to previous percent if new percent is
        outside of the permitted range. If self.checksum flag is True, then the
        set laser percent cannot be 63% defaults to 62.5% instead.

        The PWM signal duty cycle controls how much of the Command signal&#39;s
        pulse is HIGH. When the Command signal is HIGH, the laser RF amplifiers
        are HIGH and this increases the optical output power.

        If a labjack is connected, then a SET message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        per = self._pwm_percent_limits(per)
        self._percent = per
        self.percent_hist.append(per)

        if self.percent_hist[-2] != per and self._open_labjack:
            msg = Message(&#34;percent&#34;, per, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def pwm_freq(self):
        &#34;&#34;&#34;Return laser PWM frequency.&#34;&#34;&#34;
        return self._pwm_freq

    @pwm_freq.setter
    def pwm_freq(self, freq: int):
        &#34;&#34;&#34;
        Set laser PWM frequency to either 5, 10, or 20kHz.

        Parameters
        ----------
        freq : {5, 10, 20}
            New laser percent.

        Notes
        -----
        The PWM frequency of the Command signal, where the laser optical output
        follows the Command signal with a rise/fall time of 75-150us. A higher
        PWM frequency means the laser output response has less ripple and at
        20kHz the laser output is nearly CW with small ripple.

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._pwm_freq = freq
        self.pwm_freq_hist.append(freq)

        if self.pwm_freq_hist[-2] != freq and self._open_labjack:
            msg = Message(&#34;pwm_freq&#34;, freq, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def gate_logic(self):
        &#34;&#34;&#34;Return gate pull up/down status.&#34;&#34;&#34;
        return self._gate_logic

    @gate_logic.setter
    def gate_logic(self, pull: str):
        &#34;&#34;&#34;
        Set gate pull up/down status to either pull &#34;up&#34; or &#34;down&#34;.

        Parameters
        ----------
        pull : {&#34;up&#34;, &#34;down&#34;}
            New gate pull status.

        Notes
        -----
        Gate pull up indicates that the laser will fire without a gate signal.
        This means the UC-2000 connects an internal resistor between the gate
        and command signal.

        Gate pull down means the laser will fire when the gate signal is HIGH
        and the command signal is HIGH. A gate signal is supplied to the Gate
        BNC input and is either logic LOW (0 - 0.9V DC) or HIGH (2.8 - 5 V DC).
        Now, the tickle pulse and command signals are determined by the
        Gating amplitude.

        Note: PWM and gate pulses are not asynchronous, the edges of both
        pulses are not synchronised.

        Input impedence: 50 kOhms
        Gate On Time, min: 3.5us (10ms in closed loop mode)/

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._gate_logic = pull
        self.gate_logic_hist.append(pull)

        if self.gate_logic_hist[-2] != pull and self._open_labjack:
            msg = Message(&#34;gate_logic&#34;, pull, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def max_pwm(self):
        &#34;&#34;&#34;Return the maximum PWM perentage or maximum duty cycle time.&#34;&#34;&#34;
        return self._max_pwm

    @max_pwm.setter
    def max_pwm(self, per: int):
        &#34;&#34;&#34;
        Set the maximum PWM percentage of the Command signal.

        Parameters
        ----------
        per : {95, 99}
            New max PWM percentage.

        Notes
        -----
        Synrad lasers have max PWM percentage of 95% by default to increase
        longevity of lasers as greater than 95% increases heat load and &#34;may
        cause thermal instability and optical degradation.&#34;

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._max_pwm = per
        self.max_pwm_hist.append(per)

        if self.max_pwm_hist[-2] != per and self._open_labjack:
            msg = Message(&#34;max_pwm&#34;, per, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def lase_on_power_up(self):
        &#34;&#34;&#34;Return lase on power-up status.&#34;&#34;&#34;
        return self._lase_on_power_up

    @lase_on_power_up.setter
    def lase_on_power_up(self, pwr: bool):
        &#34;&#34;&#34;
        Set lase on power-up status to either True or False.

        Parameters
        ----------
        pwr : bool
            New lase on power-up setting.

        Notes
        -----
        If the lase on power-up status is ON, then the UC-2000 controller will
        send a lase signal immediately when the power is turned on. Used only
        when access to UC-2000 controller is limited.

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._lase_on_power_up = pwr
        self.lase_on_power_up_hist.append(pwr)

        if self.lase_on_power_up_hist[-2] != pwr and self._open_labjack:
            msg = Message(&#34;lase_on_power_up&#34;, pwr, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def mode(self):
        &#34;&#34;&#34;Return UC-2000 operating mode.&#34;&#34;&#34;
        return self._mode

    @mode.setter
    def mode(self, mode_type: str):
        &#34;&#34;&#34;
        Set UC-2000 operating mode to 5 possible choices.

        Parameters
        ----------
        mode_type : {&#34;manual&#34;, &#34;anc&#34;, &#34;anv&#34; &#34;man_closed&#34;, &#34;anv_closed&#34;}
            New operating mode.

        Notes
        -----
        MANUAL (&#34;manual&#34;)
        Laser output power is adjusted by the PWM command signal duty cycle
        percentage.

        ANC (&#34;anc&#34;)
        Laser power controlled by external 4-20mA current loop. PWM duty cycle
        changes proportionally to applied current.

        ANV (&#34;anv&#34;)
        Laser power controlled by external analog 0-10V source where the duty
        cycle is proportional to external voltage.

        MAN. CLOSED (&#34;man_closed&#34;)
        Closed loop power is ensured by Closed Loop Stablization Kit which
        regulates power stability to within +/-2% of the setpoint. Closed loop
        settling time is typically 2ms after setpoint change. The recommended
        lower and upper control range is 20-80% PWM duty cycle percent.

        ANV CLOSED (&#34;anv_closed&#34;)
        Similar to MAN. CLOSED except an external analog voltage is stabilised.

        If a labjack is connected, then a MODE message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._mode = mode_type.lower()
        self.mode_hist.append(mode_type)

        if self.mode_hist[-2] != mode_type and self._open_labjack:
            msg = Message(&#34;mode&#34;, mode_type, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def checksum(self):
        &#34;&#34;&#34;Return checksum protocol use.&#34;&#34;&#34;
        return self._checksum

    @checksum.setter
    def checksum(self, check: bool):
        &#34;&#34;&#34;
        Set checksum protocol used for commands sent through the RS-232 protocol.

        Parameters
        ----------
        check : bool
            New checksum enable or disable option.

        Notes
        -----
        Only changes the message sent by Python and not the message sent by the
        UC-2000. That setting must be physcially changed on the controller.

        Enabled checksum means messages are sent with a final checksum byte
        used to better handle errors with serial communication. Details on the
        checksum byte and other message formats can be found in the
        &#34;Message.py&#34; class.
        &#34;&#34;&#34;
        self._checksum = check
        self.checksum_hist.append(check)

    @property
    def max_power(self):
        &#34;&#34;&#34;Return estimated maximum output optical power of the laser based on the model and the max_pwm setting in Watts.&#34;&#34;&#34;
        est_max_power = self.model * self.max_pwm / 100
        return est_max_power

    @property
    def power(self):
        &#34;&#34;&#34;Return current estimated output optical power of the laser in Watts.&#34;&#34;&#34;
        return self.model * self.percent / 100

    def reset(self):
        &#34;&#34;&#34;Reset all UC-2000 settings to default.&#34;&#34;&#34;
        # TODO: have reset flag such that it forces all the bottom changes
        self.pwm_freq = self._default[&#34;pwm_freq&#34;]
        self.gate_logic = self._default[&#34;gate_logic&#34;]
        self.max_pwm = self._default[&#34;max_pwm&#34;]
        self.lase_on_power_up = self._default[&#34;lase_on_power_up&#34;]

        self.mode = self._default[&#34;mode&#34;]
        self.lase = self._default[&#34;lase&#34;]
        self.percent = self._default[&#34;percent&#34;]    # in percent

    def _pwm_percent_limits(self, limit_per: float):
        &#34;&#34;&#34;
        Limits input PWM percent to (0, 95/99) and converting &#39;63%&#39; to &#39;62.5%&#39;.

        If input is larger than current max PWM setting then reset to
        previous PWM percent.

        Parameters
        ----------
        limit_per : float
            Input percent.

        Returns
        -------
        setpoint : float
            Actual valid setpoint.
        &#34;&#34;&#34;
        # Check if the input percent is an int or float
        try:
            limit_per = float(limit_per)
        except (ValueError, TypeError):
            # make new error here?
            raise ValueError(&#34;Not a valid input percent&#34;)

        if limit_per &gt; self.max_pwm:
            # Set to previous percent
            setpoint = self.percent
        elif limit_per &lt; 0:
            # Set to 0 if negative
            setpoint = 0
        else:
            # Changes setpoint to be multiple of 0.5
            setpoint = self.percent_step * round(limit_per / self.percent_step)

        # FIXME: only change this for if checksum if False
        # Changes setpoint from 63 to 62.5% if checksum mode is disabled
        if setpoint in _PERCENT_TRANSFORMS:
            setpoint = _PERCENT_TRANSFORMS[setpoint]

        # TODO: make this to logging instead?
        print(&#34;Setpoint is {0}%&#34;.format(setpoint))
        return setpoint

    @staticmethod
    def _shot_time_limits(shot: float):
        &#34;&#34;&#34;
        Limits input shot time to between 50ms to 10s.

        If oustide the permitted range then the shot time is 50ms.

        Parameters
        ----------
        shot : float
            Input shot time in ms.

        Returns
        -------
        float
            Valid shot time in ms.

        Notes
        -----
        Shot time is the time between the laser ON and OFF state, which can be
        either:
            - Turning the command signal between ON and OFF
            - Setting the PWM command signal percent to the minimum lase value
            - Switching the Gate signal between HIGH and LOW

        Currently limited by communication speed between Python script and
        UC-2000 controller.
        &#34;&#34;&#34;
        try:
            shot = float(shot)
        except (ValueError, TypeError):
            # make new error here?
            raise ValueError(&#34;Not a valid shot time&#34;)

        if shot &lt; min(SHOT_TIME_RANGE):
            return min(SHOT_TIME_RANGE)
        elif shot &gt; max(SHOT_TIME_RANGE):
            return min(SHOT_TIME_RANGE)
        else:
            return shot

    def shoot(self, shot_percent: float, shot_time: float, num_shots: int):
        &#34;&#34;&#34;
        Shoots a laser shot by using PWM percent sequence of LOW, HIGH, LOW.

        Currently, the low laser percent is 3% as this doesn&#39;t affect the
        silica glass rods we are using, however, the option can be set in the
        script above.

        Parameters
        ----------
        shot_percent : float
            PWM laser percent.
        shot_time : float
            Time of shot in ms.
        num_shots : int
            Number of consecutive shots.

        Returns
        -------
        dict
            Dict containing average interval time, total time, and any response
            from UC-2000.

        Notes
        -----
        Shot time can be guaranteed but time between shots might be less
        accurate.

        If shooting more than once, the time between shots is the same time as
        the shot time.

        Examples
        --------
        &gt;&gt;&gt; laser = UC2000Controller(model=25)
        &gt;&gt;&gt; with laser:
        ...     laser.shoot(10, 500, 2)

        Fires 2 shots for 500ms at 10% PWM duty cycle percent.
        &#34;&#34;&#34;
        shot_time = self._shot_time_limits(shot_time)
        # Convert shot_time to microseconds

        # operations inside the interval.. Labjack interval ensures that the
        # percent should be this for the selected shot_time
        def ops_inside(idx):
            if idx % 2 == 0:
                self.percent = shot_percent
            elif idx % 2 == 1:
                self.percent = MIN_LASE_PERCENT
            return idx + 1, &#34;&#34;

        # operations outside the interval occur as soon as the host sends the
        # command to Labjack
        def ops_outside(idx):
            self.percent = MIN_LASE_PERCENT
            return idx, &#34;&#34;

        self.percent = MIN_LASE_PERCENT
        self.lase = True
        if self._open_labjack:
            # Interval_number is 2*num_shots - 1 because the operations outside
            # end the shot so need odd number of iterations to ensure correct
            # number of shots
            self._open_labjack.add_interval(int(shot_time*1e3), 2*num_shots - 1)
            with self._open_labjack:
                interval_metrics = self._open_labjack.interval.start_interval(
                    operations_inside=ops_inside,
                    operations_outside=ops_outside
                    )
        else:
            interval_metrics = {}
        self.percent = MIN_LASE_PERCENT
        self.lase = False
        self.shot_time_hist += [shot_time]*num_shots
        return interval_metrics


# =============================================================================
# Parameters for Message object
# =============================================================================

# Dict for converting between command name and byte
_UC2000_COMMAND_BYTES = {
    &#34;pwm_freq&#34;: {
        5: 0x77,
        10: 0x78,
        20: 0x7a
    },
    &#34;gate_logic&#34;: {
        &#34;up&#34;: 0x7a,
        &#34;down&#34;: 0x7b
    },
    &#34;max_pwm&#34;: {
        95: 0x7c,
        99: 0x7d,
    },
    &#34;lase_on_power_up&#34;: {
        True: 0x30,
        False: 0x31
    },
    &#34;mode&#34; : {
        &#34;manual&#34;: 0x70,
        &#34;anc&#34;: 0x71,
        &#34;anv&#34;: 0x72,
        &#34;man_closed&#34;: 0x73,
        &#34;anv_closed&#34;: 0x74,
    },
    &#34;lase&#34;: {
        True: 0x75,
        False: 0x76,
    },
}

class Message():
    &#34;&#34;&#34;
    REMOTE Message sent to UC-2000 on REMOTE mode through RS-232 serial
    port.

    Parameters
    ----------
    command : {&#34;pwm_freq&#34;, &#34;gate_logic&#34;, &#34;max_pwm&#34;, &#34;lase_on_power_up&#34;, &#34;mode&#34;, &#34;lase&#34;, &#34;percent&#34;, &#34;status_request&#34;}
        Command name, will be converted to command byte.
    data : float
        Data for PWM (or SET for closed loop) command.
    checksum : bool
        Checksum protocol mode.

    Notes
    -----
    There are 5 types of messages with different formats sent;
        Setup (&#34;pwm_freq&#34;, &#34;gate_logic&#34;, &#34;max_pwm&#34;, &#34;lase_on_power_up&#34;)
        Mode (&#34;mode&#34;)
        PWM (or closed loop SET) (&#34;percent&#34;)
        Lase (&#34;lase&#34;)
        Status Request

    Setup Mode, and Lase commands have the byte sequence:
        STX&lt;Command&gt;&lt;Checksum&gt;
        STX - start transmission byte.
        The checksum byte is the one&#39;s compliment of the Command byte.

    PWM (or SET) command byte sequence:
        STX&lt;Command&gt;&lt;Data Byte&gt;&lt;Checksum&gt;
        Data byte is the PWM percentage multipled by 2, converted into hex.
        The checksum byte is the adding without carry between command and
        data byte and then performing the one&#39;s compliment.

    Response from Setup, Mode, Lase, and PWM is either ACK (0xAA) or NAK
    (0x3F). A NAK is sent if there is no valid command or checksum byte
    sent within 1s of STX byte or if the checksum byte is wrong.

    Status Request:
        Single byte to tell UC-2000 to report it&#39;s status.

    Response from Status Request is
        ACK&lt;Status Byte1&gt;&lt;Status Byte2&gt;&lt;PWM Byte&gt;&lt;Power Byte&gt;&lt;Checksum&gt;
        Refer to the UC-2000 manual for futher details about the contents
        of the response bytes. Currently not using so not as important.

    TODO: include parsing response byte from UC-2000

    Examples
    --------
    &gt;&gt;&gt; message = Message(&#34;percent&#34;, 10, False)
    &gt;&gt;&gt; message.message_bytes()
    [126, 127, 20]

    Create message for setting PWM percent to 10%.

    &gt;&gt;&gt; message = Message(&#34;lase&#34;, True, False)
    &gt;&gt;&gt; message.message_bytes()
    [126, 127, 117]

    Create message for turning on command signal.
    &#34;&#34;&#34;
    _start_byte = 0x5b
    # (STX) First byte sent to initialise communication, not needed when sending request.
    _status_request_byte = 0x7e
    _set_percent_byte = 0x7f

    def __init__(self, command: str, data, checksum: bool):
        &#34;&#34;&#34;Inits a Message object.&#34;&#34;&#34;
        self.command = command
        &#34;&#34;&#34;Command to perform&#34;&#34;&#34;
        self.checksum = checksum
        &#34;&#34;&#34;Checksum protocol mode.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for PWM (or SET for closed loop) command.&#34;&#34;&#34;

    @property
    def message_bytes(self):
        &#34;&#34;&#34;
        Creates and returns REMOTE message byte sequence.

        Returns
        -------
        message : list of int
            The message sequence containing the start byte, command byte,
            [data byte (optional)], and checksum (optional)
        &#34;&#34;&#34;
        if self.command in _UC2000_COMMAND_BYTES.keys():
            command_byte = _UC2000_COMMAND_BYTES[self.command][self.data]

            message = [self._start_byte, command_byte]

            if self.checksum:
                # without data, the checksum is the one&#39;s compliment of the
                # command byte
                checksum_byte = ~command_byte &amp; 0xff
                message.append(checksum_byte)

        elif self.command == &#34;percent&#34;:
            try:
                message = [
                    self._start_byte, self._set_percent_byte, int(2*self.data)]
            except ValueError:
                raise ValueError(
            &#34;Type of data is invalid. Needs to be float or int.&#34;)

            if self.checksum:
                # with data, the checksum is the addition without carry of the
                # command and data byte and then one&#39;s complimented
                checksum_byte = (
                    ~self.add_no_carry(
                        self._set_percent_byte, self.data) &amp; 0xff
                    )
                message.append(checksum_byte)

        elif self.command == &#34;status_request&#34;:
            message = [self._status_request_byte]

        else:
            raise ValueError(&#34;Command is not recognised by UC-2000&#34;)

        return message

    @staticmethod
    def add_no_carry(*args):
        &#34;&#34;&#34;
        Addition without carry; addition is not carried to the next decimal up.

        Parameters
        ----------
        *args : iterable (not string)
            Iterate of ints to add without carry.

        Returns
        -------
        final_sum : int
            the result...

        Examples
        --------
        &gt;&gt;&gt; add_no_carry(1, 1)
        2

        &gt;&gt;&gt; add_no_carry(1, 18)
        19

        &gt;&gt;&gt; add_no_carry(1, 19)
        10

        The &#39;10&#39; is not carried over to the next decimal.
        &#34;&#34;&#34;
        num_digits = []

        for arg in args:
            num_digits.append(len(str(arg)))

        max_digits = max(num_digits)
        # list comprehension way
        # max_digits = max([len(str(arg)) for arg in args])
        final_sum = 0

        for pwr in range(1, max_digits + 1): # iterate through ea decimal
            result_no_carry = 0
            for arg in args:
                if len(str(arg)) &gt;= pwr:
                    # modulus sets the current decimal as the most significant
                    # decimal
                    # floor div selects the most significant decimal
                    result_no_carry += arg % 10**pwr // 10**(pwr - 1)

            # list comprehension way
            # result_no_carry = sum([arg % 10**pwr // 10**(pwr - 1) for arg in args if len(str(arg)) &gt;= pwr])

            # final_sum = str(result_no_carry % 10) + final_sum
            final_sum += result_no_carry % 10

        return int(final_sum)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="uc2000.MIN_LASE_PERCENT"><code class="name">var <span class="ident">MIN_LASE_PERCENT</span></code></dt>
<dd>
<div class="desc"><p>Minimum percent required for laser to be considered OFF to material without
turning the Command signal OFF.</p></div>
</dd>
<dt id="uc2000.SHOT_TIME_RANGE"><code class="name">var <span class="ident">SHOT_TIME_RANGE</span></code></dt>
<dd>
<div class="desc"><p>Valid shot time range.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uc2000.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>command:Â str, data, checksum:Â bool)</span>
</code></dt>
<dd>
<div class="desc"><p>REMOTE Message sent to UC-2000 on REMOTE mode through RS-232 serial
port.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>command</code></strong> :&ensp;<code>{"pwm_freq", "gate_logic", "max_pwm", "lase_on_power_up", "mode", "lase", "percent", "status_request"}</code></dt>
<dd>Command name, will be converted to command byte.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>float</code></dt>
<dd>Data for PWM (or SET for closed loop) command.</dd>
<dt><strong><code>checksum</code></strong> :&ensp;<code>bool</code></dt>
<dd>Checksum protocol mode.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>There are 5 types of messages with different formats sent;
Setup ("pwm_freq", "gate_logic", "max_pwm", "lase_on_power_up")
Mode ("mode")
PWM (or closed loop SET) ("percent")
Lase ("lase")
Status Request</p>
<p>Setup Mode, and Lase commands have the byte sequence:
STX<Command><Checksum>
STX - start transmission byte.
The checksum byte is the one's compliment of the Command byte.</p>
<p>PWM (or SET) command byte sequence:
STX<Command><Data Byte><Checksum>
Data byte is the PWM percentage multipled by 2, converted into hex.
The checksum byte is the adding without carry between command and
data byte and then performing the one's compliment.</p>
<p>Response from Setup, Mode, Lase, and PWM is either ACK (0xAA) or NAK
(0x3F). A NAK is sent if there is no valid command or checksum byte
sent within 1s of STX byte or if the checksum byte is wrong.</p>
<p>Status Request:
Single byte to tell UC-2000 to report it's status.</p>
<p>Response from Status Request is
ACK<Status Byte1><Status Byte2><PWM Byte><Power Byte><Checksum>
Refer to the UC-2000 manual for futher details about the contents
of the response bytes. Currently not using so not as important.</p>
<p>TODO: include parsing response byte from UC-2000</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; message = Message(&quot;percent&quot;, 10, False)
&gt;&gt;&gt; message.message_bytes()
[126, 127, 20]
</code></pre>
<p>Create message for setting PWM percent to 10%.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; message = Message(&quot;lase&quot;, True, False)
&gt;&gt;&gt; message.message_bytes()
[126, 127, 117]
</code></pre>
<p>Create message for turning on command signal.</p>
<p>Inits a Message object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message():
    &#34;&#34;&#34;
    REMOTE Message sent to UC-2000 on REMOTE mode through RS-232 serial
    port.

    Parameters
    ----------
    command : {&#34;pwm_freq&#34;, &#34;gate_logic&#34;, &#34;max_pwm&#34;, &#34;lase_on_power_up&#34;, &#34;mode&#34;, &#34;lase&#34;, &#34;percent&#34;, &#34;status_request&#34;}
        Command name, will be converted to command byte.
    data : float
        Data for PWM (or SET for closed loop) command.
    checksum : bool
        Checksum protocol mode.

    Notes
    -----
    There are 5 types of messages with different formats sent;
        Setup (&#34;pwm_freq&#34;, &#34;gate_logic&#34;, &#34;max_pwm&#34;, &#34;lase_on_power_up&#34;)
        Mode (&#34;mode&#34;)
        PWM (or closed loop SET) (&#34;percent&#34;)
        Lase (&#34;lase&#34;)
        Status Request

    Setup Mode, and Lase commands have the byte sequence:
        STX&lt;Command&gt;&lt;Checksum&gt;
        STX - start transmission byte.
        The checksum byte is the one&#39;s compliment of the Command byte.

    PWM (or SET) command byte sequence:
        STX&lt;Command&gt;&lt;Data Byte&gt;&lt;Checksum&gt;
        Data byte is the PWM percentage multipled by 2, converted into hex.
        The checksum byte is the adding without carry between command and
        data byte and then performing the one&#39;s compliment.

    Response from Setup, Mode, Lase, and PWM is either ACK (0xAA) or NAK
    (0x3F). A NAK is sent if there is no valid command or checksum byte
    sent within 1s of STX byte or if the checksum byte is wrong.

    Status Request:
        Single byte to tell UC-2000 to report it&#39;s status.

    Response from Status Request is
        ACK&lt;Status Byte1&gt;&lt;Status Byte2&gt;&lt;PWM Byte&gt;&lt;Power Byte&gt;&lt;Checksum&gt;
        Refer to the UC-2000 manual for futher details about the contents
        of the response bytes. Currently not using so not as important.

    TODO: include parsing response byte from UC-2000

    Examples
    --------
    &gt;&gt;&gt; message = Message(&#34;percent&#34;, 10, False)
    &gt;&gt;&gt; message.message_bytes()
    [126, 127, 20]

    Create message for setting PWM percent to 10%.

    &gt;&gt;&gt; message = Message(&#34;lase&#34;, True, False)
    &gt;&gt;&gt; message.message_bytes()
    [126, 127, 117]

    Create message for turning on command signal.
    &#34;&#34;&#34;
    _start_byte = 0x5b
    # (STX) First byte sent to initialise communication, not needed when sending request.
    _status_request_byte = 0x7e
    _set_percent_byte = 0x7f

    def __init__(self, command: str, data, checksum: bool):
        &#34;&#34;&#34;Inits a Message object.&#34;&#34;&#34;
        self.command = command
        &#34;&#34;&#34;Command to perform&#34;&#34;&#34;
        self.checksum = checksum
        &#34;&#34;&#34;Checksum protocol mode.&#34;&#34;&#34;
        self.data = data
        &#34;&#34;&#34;Data for PWM (or SET for closed loop) command.&#34;&#34;&#34;

    @property
    def message_bytes(self):
        &#34;&#34;&#34;
        Creates and returns REMOTE message byte sequence.

        Returns
        -------
        message : list of int
            The message sequence containing the start byte, command byte,
            [data byte (optional)], and checksum (optional)
        &#34;&#34;&#34;
        if self.command in _UC2000_COMMAND_BYTES.keys():
            command_byte = _UC2000_COMMAND_BYTES[self.command][self.data]

            message = [self._start_byte, command_byte]

            if self.checksum:
                # without data, the checksum is the one&#39;s compliment of the
                # command byte
                checksum_byte = ~command_byte &amp; 0xff
                message.append(checksum_byte)

        elif self.command == &#34;percent&#34;:
            try:
                message = [
                    self._start_byte, self._set_percent_byte, int(2*self.data)]
            except ValueError:
                raise ValueError(
            &#34;Type of data is invalid. Needs to be float or int.&#34;)

            if self.checksum:
                # with data, the checksum is the addition without carry of the
                # command and data byte and then one&#39;s complimented
                checksum_byte = (
                    ~self.add_no_carry(
                        self._set_percent_byte, self.data) &amp; 0xff
                    )
                message.append(checksum_byte)

        elif self.command == &#34;status_request&#34;:
            message = [self._status_request_byte]

        else:
            raise ValueError(&#34;Command is not recognised by UC-2000&#34;)

        return message

    @staticmethod
    def add_no_carry(*args):
        &#34;&#34;&#34;
        Addition without carry; addition is not carried to the next decimal up.

        Parameters
        ----------
        *args : iterable (not string)
            Iterate of ints to add without carry.

        Returns
        -------
        final_sum : int
            the result...

        Examples
        --------
        &gt;&gt;&gt; add_no_carry(1, 1)
        2

        &gt;&gt;&gt; add_no_carry(1, 18)
        19

        &gt;&gt;&gt; add_no_carry(1, 19)
        10

        The &#39;10&#39; is not carried over to the next decimal.
        &#34;&#34;&#34;
        num_digits = []

        for arg in args:
            num_digits.append(len(str(arg)))

        max_digits = max(num_digits)
        # list comprehension way
        # max_digits = max([len(str(arg)) for arg in args])
        final_sum = 0

        for pwr in range(1, max_digits + 1): # iterate through ea decimal
            result_no_carry = 0
            for arg in args:
                if len(str(arg)) &gt;= pwr:
                    # modulus sets the current decimal as the most significant
                    # decimal
                    # floor div selects the most significant decimal
                    result_no_carry += arg % 10**pwr // 10**(pwr - 1)

            # list comprehension way
            # result_no_carry = sum([arg % 10**pwr // 10**(pwr - 1) for arg in args if len(str(arg)) &gt;= pwr])

            # final_sum = str(result_no_carry % 10) + final_sum
            final_sum += result_no_carry % 10

        return int(final_sum)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="uc2000.Message.add_no_carry"><code class="name flex">
<span>def <span class="ident">add_no_carry</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Addition without carry; addition is not carried to the next decimal up.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>iterable (not string)</code></dt>
<dd>Iterate of ints to add without carry.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>final_sum</code></strong> :&ensp;<code>int</code></dt>
<dd>the result&hellip;</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; add_no_carry(1, 1)
2
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; add_no_carry(1, 18)
19
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; add_no_carry(1, 19)
10
</code></pre>
<p>The '10' is not carried over to the next decimal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_no_carry(*args):
    &#34;&#34;&#34;
    Addition without carry; addition is not carried to the next decimal up.

    Parameters
    ----------
    *args : iterable (not string)
        Iterate of ints to add without carry.

    Returns
    -------
    final_sum : int
        the result...

    Examples
    --------
    &gt;&gt;&gt; add_no_carry(1, 1)
    2

    &gt;&gt;&gt; add_no_carry(1, 18)
    19

    &gt;&gt;&gt; add_no_carry(1, 19)
    10

    The &#39;10&#39; is not carried over to the next decimal.
    &#34;&#34;&#34;
    num_digits = []

    for arg in args:
        num_digits.append(len(str(arg)))

    max_digits = max(num_digits)
    # list comprehension way
    # max_digits = max([len(str(arg)) for arg in args])
    final_sum = 0

    for pwr in range(1, max_digits + 1): # iterate through ea decimal
        result_no_carry = 0
        for arg in args:
            if len(str(arg)) &gt;= pwr:
                # modulus sets the current decimal as the most significant
                # decimal
                # floor div selects the most significant decimal
                result_no_carry += arg % 10**pwr // 10**(pwr - 1)

        # list comprehension way
        # result_no_carry = sum([arg % 10**pwr // 10**(pwr - 1) for arg in args if len(str(arg)) &gt;= pwr])

        # final_sum = str(result_no_carry % 10) + final_sum
        final_sum += result_no_carry % 10

    return int(final_sum)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uc2000.Message.checksum"><code class="name">var <span class="ident">checksum</span></code></dt>
<dd>
<div class="desc"><p>Checksum protocol mode.</p></div>
</dd>
<dt id="uc2000.Message.command"><code class="name">var <span class="ident">command</span></code></dt>
<dd>
<div class="desc"><p>Command to perform</p></div>
</dd>
<dt id="uc2000.Message.data"><code class="name">var <span class="ident">data</span></code></dt>
<dd>
<div class="desc"><p>Data for PWM (or SET for closed loop) command.</p></div>
</dd>
<dt id="uc2000.Message.message_bytes"><code class="name">var <span class="ident">message_bytes</span></code></dt>
<dd>
<div class="desc"><p>Creates and returns REMOTE message byte sequence.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>list</code> of <code>int</code></dt>
<dd>The message sequence containing the start byte, command byte,
[data byte (optional)], and checksum (optional)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message_bytes(self):
    &#34;&#34;&#34;
    Creates and returns REMOTE message byte sequence.

    Returns
    -------
    message : list of int
        The message sequence containing the start byte, command byte,
        [data byte (optional)], and checksum (optional)
    &#34;&#34;&#34;
    if self.command in _UC2000_COMMAND_BYTES.keys():
        command_byte = _UC2000_COMMAND_BYTES[self.command][self.data]

        message = [self._start_byte, command_byte]

        if self.checksum:
            # without data, the checksum is the one&#39;s compliment of the
            # command byte
            checksum_byte = ~command_byte &amp; 0xff
            message.append(checksum_byte)

    elif self.command == &#34;percent&#34;:
        try:
            message = [
                self._start_byte, self._set_percent_byte, int(2*self.data)]
        except ValueError:
            raise ValueError(
        &#34;Type of data is invalid. Needs to be float or int.&#34;)

        if self.checksum:
            # with data, the checksum is the addition without carry of the
            # command and data byte and then one&#39;s complimented
            checksum_byte = (
                ~self.add_no_carry(
                    self._set_percent_byte, self.data) &amp; 0xff
                )
            message.append(checksum_byte)

    elif self.command == &#34;status_request&#34;:
        message = [self._status_request_byte]

    else:
        raise ValueError(&#34;Command is not recognised by UC-2000&#34;)

    return message</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="uc2000.UC2000Controller"><code class="flex name class">
<span>class <span class="ident">UC2000Controller</span></span>
<span>(</span><span>model:Â int, open_labjack=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An interface to SYNRAD 48 series CO2 lasers through UC-2000 controller.</p>
<p>Communication to the UC-2000 controller from a host using REMOTE
settings are facilitated through the Serial RS-232 protocol and port.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>{25, 50}</code></dt>
<dd>SYNRAD 48 series laser model number, indicates the maximum
optical power output.</dd>
<dt><strong><code>open_labjack</code></strong> :&ensp;<code>LabJack object</code></dt>
<dd>A LabJack object to transmit messages to the UC-2000,
by default <code>False</code>.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>PARAMETER_NAME_hist</code></strong> :&ensp;<code>list</code></dt>
<dd>Entire history of previous PARAMETER_NAME from instantiation.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Pins 2, 3, and 5 of a serial port are used for receive, transmit, and
ground respectively.
The host serial port configuration must be
Baud rate
9600
Data bits
8 bits
Parity
None
Stop bits
1 bit
Flow control
None</p>
<p>For further details please refer to:
<a href="https://synrad.com/en/products/accessories/uc-2000">https://synrad.com/en/products/accessories/uc-2000</a></p>
<p><code><a title="uc2000.Message" href="#uc2000.Message">Message</a></code>s are sent to the UC-2000 from the host via a DAQ, in this case
a LabJack T4/T7 is used. However, any source that can produce RS-232
asynchronous communication can be used. If a Labjack object or no other
DAQ is provided then the UC-2000 only stores messages.</p>
<p>TODO: LUA scripting - call script to improve timings
TODO: gate pull-up/down, SYNRAD doesn't know whether gate or comamnd signal activate lasing is faster. Trial and error?</p>
<p>TODO: receiving communication from the labjack&hellip; or using the UC2000 response
if check_ack:
daq_response = daq_stats["response"]</p>
<pre><code>    if not isinstance(daq_response, list):
        daq_response = [daq_response]

    if UC2000_RESPONSE["ack"] in daq_response:
        self.laser_controller.set_any(setting, option)
        gui_message = ""{0}" has changed to "{1}"".format(setting, option)
        action = "continue"
        outcome = option
    elif UC2000_RESPONSE["nak"] in daq_response:
        gui_message = ""{0}" remains unchanged as {1} because UC2000 didn't accept the message".format(setting, prev)
        action = "previous"
        outcome = prev
    else:
        gui_message = "Setting "{0}" remains unchanged as {1} because there has been no response from UC2000".format(setting, prev)
        action = "previous"
        outcome = prev
else:
    self.laser_controller.set_any(setting, option)
    gui_message = "Setting "{0}" has changed to "{1}"".format(setting, option)
    action = "continue"
    outcome = option
</code></pre>
<p>TODO: test with slightly longer wait time between asynch communications
TODO: can send remote status byte inbetween start and end transmission byte of any other
command - maybe use to check option on laser</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; laser = UC2000Controller(model=25)
&gt;&gt;&gt; with laser:
...     laser.percent = 20
...     laser.lase = True
...     laser.percent = 0
...     laser.lase = False
</code></pre>
<p>Demonstration of the .percent and .lase commands</p>
<p>Inits a UC2000 object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UC2000Controller:
    &#34;&#34;&#34;
    An interface to SYNRAD 48 series CO2 lasers through UC-2000 controller.

    Communication to the UC-2000 controller from a host using REMOTE
    settings are facilitated through the Serial RS-232 protocol and port.

    Parameters
    ----------
    model : {25, 50}
        SYNRAD 48 series laser model number, indicates the maximum
        optical power output.
    open_labjack : LabJack object
        A LabJack object to transmit messages to the UC-2000,
        by default ``False``.

    Attributes
    ----------
    PARAMETER_NAME_hist : list
        Entire history of previous PARAMETER_NAME from instantiation.

    Notes
    -----
    Pins 2, 3, and 5 of a serial port are used for receive, transmit, and
    ground respectively.
    The host serial port configuration must be
        Baud rate       9600
        Data bits       8 bits
        Parity          None
        Stop bits       1 bit
        Flow control    None

    For further details please refer to:
    https://synrad.com/en/products/accessories/uc-2000

    `uc2000.Message`s are sent to the UC-2000 from the host via a DAQ, in this case
    a LabJack T4/T7 is used. However, any source that can produce RS-232
    asynchronous communication can be used. If a Labjack object or no other
    DAQ is provided then the UC-2000 only stores messages.

    TODO: LUA scripting - call script to improve timings
    TODO: gate pull-up/down, SYNRAD doesn&#39;t know whether gate or comamnd signal activate lasing is faster. Trial and error?

    TODO: receiving communication from the labjack... or using the UC2000 response
        if check_ack:
            daq_response = daq_stats[&#34;response&#34;]

            if not isinstance(daq_response, list):
                daq_response = [daq_response]

            if UC2000_RESPONSE[&#34;ack&#34;] in daq_response:
                self.laser_controller.set_any(setting, option)
                gui_message = &#34;\&#34;{0}\&#34; has changed to \&#34;{1}\&#34;&#34;.format(setting, option)
                action = &#34;continue&#34;
                outcome = option
            elif UC2000_RESPONSE[&#34;nak&#34;] in daq_response:
                gui_message = &#34;\&#34;{0}\&#34; remains unchanged as {1} because UC2000 didn&#39;t accept the message&#34;.format(setting, prev)
                action = &#34;previous&#34;
                outcome = prev
            else:
                gui_message = &#34;Setting \&#34;{0}\&#34; remains unchanged as {1} because there has been no response from UC2000&#34;.format(setting, prev)
                action = &#34;previous&#34;
                outcome = prev
        else:
            self.laser_controller.set_any(setting, option)
            gui_message = &#34;Setting \&#34;{0}\&#34; has changed to \&#34;{1}\&#34;&#34;.format(setting, option)
            action = &#34;continue&#34;
            outcome = option

    TODO: test with slightly longer wait time between asynch communications
    TODO: can send remote status byte inbetween start and end transmission byte of any other
    command - maybe use to check option on laser

    Examples
    --------
    &gt;&gt;&gt; laser = UC2000Controller(model=25)
    &gt;&gt;&gt; with laser:
    ...     laser.percent = 20
    ...     laser.lase = True
    ...     laser.percent = 0
    ...     laser.lase = False

    Demonstration of the .percent and .lase commands
    &#34;&#34;&#34;

    percent_step = 0.5
    &#34;&#34;&#34;Minimum step size of PWM percent.&#34;&#34;&#34;

    _default = {
        &#34;pwm_freq&#34;:         20,   # Higher PWM frequency means lower ripple in optical beam response
        &#34;gate_logic&#34;:       &#34;up&#34;,
        &#34;max_pwm&#34;:          95,
        &#34;lase_on_power_up&#34;: False,
        &#34;mode&#34;:             &#34;manual&#34;, # this will be different for reflow and laser machining
        &#34;lase&#34;:             False,
        &#34;percent&#34;:          0,
    }
    # TODO: update RC params style?
    # TODO: set defaults list into controller as argument for changable settings

    def __init__(self, model: int, open_labjack=False):
        &#34;&#34;&#34;Inits a UC2000 object.&#34;&#34;&#34;
        self.model = model

        self._open_labjack = open_labjack

        self.pwm_freq_hist = [None]
        self.gate_logic_hist = [None]
        self.max_pwm_hist = [None]
        self.lase_on_power_up_hist = [None]
        self.mode_hist = [None]
        self.lase_hist = [None]
        self.percent_hist = [None]
        self.checksum_hist = []
        self.shot_time_hist = []

        # Assumes that Checksum mode is enabled...
        # and why would we not use checksum mode anyways
        self.checksum = True

        self.reset()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        if exc_type is KeyboardInterrupt:
            print(&#34;Laser process stopped by user&#34;)
            self.percent = 0
            self.lase = False
            # returning False because we want to allow nested with statements
            # above the stack to also use their __exit__ which turns the laser
            # off and low set percent.
            return False

        # turn it down anyways
        self.percent = 0
        self.lase = False
        return exc_type is None

    @property
    def lase(self):
        &#34;&#34;&#34;Return lase state.&#34;&#34;&#34;
        return self._lase

    @lase.setter
    def lase(self, state: bool):
        &#34;&#34;&#34;
        Set lase state to either True or False.

        Parameters
        ----------
        state : bool
            New set lase state.

        Notes
        -----
        Lase state is controlled by a Command signal for LOW (0 - 0.5V DC)
        and HIGH (3.5 - 5V DC).

        When the Command signal is low for &gt;200us, the UC-2000 always supplies
        laser with 5kHz, 1us tickle pulse that pre-ionises the laser gas to
        just below lasing threshold. Any increase in pulse width causes
        emission as enough energy is added to the plasma.

        If a labjack is connected, then a LASE message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._lase = state
        self.lase_hist.append(state)

        # if the new option is the same as before don&#39;t send changes to labjack
        if (self.lase_hist[-2] != state) and self._open_labjack:
            msg = Message(&#34;lase&#34;, state, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def percent(self):
        &#34;&#34;&#34;Return laser percent, representing the PWM signal duty cycle percentage.&#34;&#34;&#34;
        return self._percent

    @percent.setter
    def percent(self, per: float):
        &#34;&#34;&#34;
        Set laser percent (PWM signal duty cycle percentage), limited to
        between 0 and 95/99% in steps of 0.5%.

        Parameters
        ----------
        per : float
            New PWM duty cycle percentage, in seteps of 0.5%

        Notes
        -----
        The laser percent defaults to previous percent if new percent is
        outside of the permitted range. If self.checksum flag is True, then the
        set laser percent cannot be 63% defaults to 62.5% instead.

        The PWM signal duty cycle controls how much of the Command signal&#39;s
        pulse is HIGH. When the Command signal is HIGH, the laser RF amplifiers
        are HIGH and this increases the optical output power.

        If a labjack is connected, then a SET message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        per = self._pwm_percent_limits(per)
        self._percent = per
        self.percent_hist.append(per)

        if self.percent_hist[-2] != per and self._open_labjack:
            msg = Message(&#34;percent&#34;, per, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def pwm_freq(self):
        &#34;&#34;&#34;Return laser PWM frequency.&#34;&#34;&#34;
        return self._pwm_freq

    @pwm_freq.setter
    def pwm_freq(self, freq: int):
        &#34;&#34;&#34;
        Set laser PWM frequency to either 5, 10, or 20kHz.

        Parameters
        ----------
        freq : {5, 10, 20}
            New laser percent.

        Notes
        -----
        The PWM frequency of the Command signal, where the laser optical output
        follows the Command signal with a rise/fall time of 75-150us. A higher
        PWM frequency means the laser output response has less ripple and at
        20kHz the laser output is nearly CW with small ripple.

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._pwm_freq = freq
        self.pwm_freq_hist.append(freq)

        if self.pwm_freq_hist[-2] != freq and self._open_labjack:
            msg = Message(&#34;pwm_freq&#34;, freq, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def gate_logic(self):
        &#34;&#34;&#34;Return gate pull up/down status.&#34;&#34;&#34;
        return self._gate_logic

    @gate_logic.setter
    def gate_logic(self, pull: str):
        &#34;&#34;&#34;
        Set gate pull up/down status to either pull &#34;up&#34; or &#34;down&#34;.

        Parameters
        ----------
        pull : {&#34;up&#34;, &#34;down&#34;}
            New gate pull status.

        Notes
        -----
        Gate pull up indicates that the laser will fire without a gate signal.
        This means the UC-2000 connects an internal resistor between the gate
        and command signal.

        Gate pull down means the laser will fire when the gate signal is HIGH
        and the command signal is HIGH. A gate signal is supplied to the Gate
        BNC input and is either logic LOW (0 - 0.9V DC) or HIGH (2.8 - 5 V DC).
        Now, the tickle pulse and command signals are determined by the
        Gating amplitude.

        Note: PWM and gate pulses are not asynchronous, the edges of both
        pulses are not synchronised.

        Input impedence: 50 kOhms
        Gate On Time, min: 3.5us (10ms in closed loop mode)/

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._gate_logic = pull
        self.gate_logic_hist.append(pull)

        if self.gate_logic_hist[-2] != pull and self._open_labjack:
            msg = Message(&#34;gate_logic&#34;, pull, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def max_pwm(self):
        &#34;&#34;&#34;Return the maximum PWM perentage or maximum duty cycle time.&#34;&#34;&#34;
        return self._max_pwm

    @max_pwm.setter
    def max_pwm(self, per: int):
        &#34;&#34;&#34;
        Set the maximum PWM percentage of the Command signal.

        Parameters
        ----------
        per : {95, 99}
            New max PWM percentage.

        Notes
        -----
        Synrad lasers have max PWM percentage of 95% by default to increase
        longevity of lasers as greater than 95% increases heat load and &#34;may
        cause thermal instability and optical degradation.&#34;

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._max_pwm = per
        self.max_pwm_hist.append(per)

        if self.max_pwm_hist[-2] != per and self._open_labjack:
            msg = Message(&#34;max_pwm&#34;, per, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def lase_on_power_up(self):
        &#34;&#34;&#34;Return lase on power-up status.&#34;&#34;&#34;
        return self._lase_on_power_up

    @lase_on_power_up.setter
    def lase_on_power_up(self, pwr: bool):
        &#34;&#34;&#34;
        Set lase on power-up status to either True or False.

        Parameters
        ----------
        pwr : bool
            New lase on power-up setting.

        Notes
        -----
        If the lase on power-up status is ON, then the UC-2000 controller will
        send a lase signal immediately when the power is turned on. Used only
        when access to UC-2000 controller is limited.

        If a labjack is connected, then a SETUP message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._lase_on_power_up = pwr
        self.lase_on_power_up_hist.append(pwr)

        if self.lase_on_power_up_hist[-2] != pwr and self._open_labjack:
            msg = Message(&#34;lase_on_power_up&#34;, pwr, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def mode(self):
        &#34;&#34;&#34;Return UC-2000 operating mode.&#34;&#34;&#34;
        return self._mode

    @mode.setter
    def mode(self, mode_type: str):
        &#34;&#34;&#34;
        Set UC-2000 operating mode to 5 possible choices.

        Parameters
        ----------
        mode_type : {&#34;manual&#34;, &#34;anc&#34;, &#34;anv&#34; &#34;man_closed&#34;, &#34;anv_closed&#34;}
            New operating mode.

        Notes
        -----
        MANUAL (&#34;manual&#34;)
        Laser output power is adjusted by the PWM command signal duty cycle
        percentage.

        ANC (&#34;anc&#34;)
        Laser power controlled by external 4-20mA current loop. PWM duty cycle
        changes proportionally to applied current.

        ANV (&#34;anv&#34;)
        Laser power controlled by external analog 0-10V source where the duty
        cycle is proportional to external voltage.

        MAN. CLOSED (&#34;man_closed&#34;)
        Closed loop power is ensured by Closed Loop Stablization Kit which
        regulates power stability to within +/-2% of the setpoint. Closed loop
        settling time is typically 2ms after setpoint change. The recommended
        lower and upper control range is 20-80% PWM duty cycle percent.

        ANV CLOSED (&#34;anv_closed&#34;)
        Similar to MAN. CLOSED except an external analog voltage is stabilised.

        If a labjack is connected, then a MODE message will be sent to the
        UC2000.
        &#34;&#34;&#34;
        self._mode = mode_type.lower()
        self.mode_hist.append(mode_type)

        if self.mode_hist[-2] != mode_type and self._open_labjack:
            msg = Message(&#34;mode&#34;, mode_type, self.checksum).message_bytes
            self._open_labjack.asynch.transmit(msg)

    @property
    def checksum(self):
        &#34;&#34;&#34;Return checksum protocol use.&#34;&#34;&#34;
        return self._checksum

    @checksum.setter
    def checksum(self, check: bool):
        &#34;&#34;&#34;
        Set checksum protocol used for commands sent through the RS-232 protocol.

        Parameters
        ----------
        check : bool
            New checksum enable or disable option.

        Notes
        -----
        Only changes the message sent by Python and not the message sent by the
        UC-2000. That setting must be physcially changed on the controller.

        Enabled checksum means messages are sent with a final checksum byte
        used to better handle errors with serial communication. Details on the
        checksum byte and other message formats can be found in the
        &#34;Message.py&#34; class.
        &#34;&#34;&#34;
        self._checksum = check
        self.checksum_hist.append(check)

    @property
    def max_power(self):
        &#34;&#34;&#34;Return estimated maximum output optical power of the laser based on the model and the max_pwm setting in Watts.&#34;&#34;&#34;
        est_max_power = self.model * self.max_pwm / 100
        return est_max_power

    @property
    def power(self):
        &#34;&#34;&#34;Return current estimated output optical power of the laser in Watts.&#34;&#34;&#34;
        return self.model * self.percent / 100

    def reset(self):
        &#34;&#34;&#34;Reset all UC-2000 settings to default.&#34;&#34;&#34;
        # TODO: have reset flag such that it forces all the bottom changes
        self.pwm_freq = self._default[&#34;pwm_freq&#34;]
        self.gate_logic = self._default[&#34;gate_logic&#34;]
        self.max_pwm = self._default[&#34;max_pwm&#34;]
        self.lase_on_power_up = self._default[&#34;lase_on_power_up&#34;]

        self.mode = self._default[&#34;mode&#34;]
        self.lase = self._default[&#34;lase&#34;]
        self.percent = self._default[&#34;percent&#34;]    # in percent

    def _pwm_percent_limits(self, limit_per: float):
        &#34;&#34;&#34;
        Limits input PWM percent to (0, 95/99) and converting &#39;63%&#39; to &#39;62.5%&#39;.

        If input is larger than current max PWM setting then reset to
        previous PWM percent.

        Parameters
        ----------
        limit_per : float
            Input percent.

        Returns
        -------
        setpoint : float
            Actual valid setpoint.
        &#34;&#34;&#34;
        # Check if the input percent is an int or float
        try:
            limit_per = float(limit_per)
        except (ValueError, TypeError):
            # make new error here?
            raise ValueError(&#34;Not a valid input percent&#34;)

        if limit_per &gt; self.max_pwm:
            # Set to previous percent
            setpoint = self.percent
        elif limit_per &lt; 0:
            # Set to 0 if negative
            setpoint = 0
        else:
            # Changes setpoint to be multiple of 0.5
            setpoint = self.percent_step * round(limit_per / self.percent_step)

        # FIXME: only change this for if checksum if False
        # Changes setpoint from 63 to 62.5% if checksum mode is disabled
        if setpoint in _PERCENT_TRANSFORMS:
            setpoint = _PERCENT_TRANSFORMS[setpoint]

        # TODO: make this to logging instead?
        print(&#34;Setpoint is {0}%&#34;.format(setpoint))
        return setpoint

    @staticmethod
    def _shot_time_limits(shot: float):
        &#34;&#34;&#34;
        Limits input shot time to between 50ms to 10s.

        If oustide the permitted range then the shot time is 50ms.

        Parameters
        ----------
        shot : float
            Input shot time in ms.

        Returns
        -------
        float
            Valid shot time in ms.

        Notes
        -----
        Shot time is the time between the laser ON and OFF state, which can be
        either:
            - Turning the command signal between ON and OFF
            - Setting the PWM command signal percent to the minimum lase value
            - Switching the Gate signal between HIGH and LOW

        Currently limited by communication speed between Python script and
        UC-2000 controller.
        &#34;&#34;&#34;
        try:
            shot = float(shot)
        except (ValueError, TypeError):
            # make new error here?
            raise ValueError(&#34;Not a valid shot time&#34;)

        if shot &lt; min(SHOT_TIME_RANGE):
            return min(SHOT_TIME_RANGE)
        elif shot &gt; max(SHOT_TIME_RANGE):
            return min(SHOT_TIME_RANGE)
        else:
            return shot

    def shoot(self, shot_percent: float, shot_time: float, num_shots: int):
        &#34;&#34;&#34;
        Shoots a laser shot by using PWM percent sequence of LOW, HIGH, LOW.

        Currently, the low laser percent is 3% as this doesn&#39;t affect the
        silica glass rods we are using, however, the option can be set in the
        script above.

        Parameters
        ----------
        shot_percent : float
            PWM laser percent.
        shot_time : float
            Time of shot in ms.
        num_shots : int
            Number of consecutive shots.

        Returns
        -------
        dict
            Dict containing average interval time, total time, and any response
            from UC-2000.

        Notes
        -----
        Shot time can be guaranteed but time between shots might be less
        accurate.

        If shooting more than once, the time between shots is the same time as
        the shot time.

        Examples
        --------
        &gt;&gt;&gt; laser = UC2000Controller(model=25)
        &gt;&gt;&gt; with laser:
        ...     laser.shoot(10, 500, 2)

        Fires 2 shots for 500ms at 10% PWM duty cycle percent.
        &#34;&#34;&#34;
        shot_time = self._shot_time_limits(shot_time)
        # Convert shot_time to microseconds

        # operations inside the interval.. Labjack interval ensures that the
        # percent should be this for the selected shot_time
        def ops_inside(idx):
            if idx % 2 == 0:
                self.percent = shot_percent
            elif idx % 2 == 1:
                self.percent = MIN_LASE_PERCENT
            return idx + 1, &#34;&#34;

        # operations outside the interval occur as soon as the host sends the
        # command to Labjack
        def ops_outside(idx):
            self.percent = MIN_LASE_PERCENT
            return idx, &#34;&#34;

        self.percent = MIN_LASE_PERCENT
        self.lase = True
        if self._open_labjack:
            # Interval_number is 2*num_shots - 1 because the operations outside
            # end the shot so need odd number of iterations to ensure correct
            # number of shots
            self._open_labjack.add_interval(int(shot_time*1e3), 2*num_shots - 1)
            with self._open_labjack:
                interval_metrics = self._open_labjack.interval.start_interval(
                    operations_inside=ops_inside,
                    operations_outside=ops_outside
                    )
        else:
            interval_metrics = {}
        self.percent = MIN_LASE_PERCENT
        self.lase = False
        self.shot_time_hist += [shot_time]*num_shots
        return interval_metrics</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="uc2000.UC2000Controller.percent_step"><code class="name">var <span class="ident">percent_step</span></code></dt>
<dd>
<div class="desc"><p>Minimum step size of PWM percent.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uc2000.UC2000Controller.checksum"><code class="name">var <span class="ident">checksum</span></code></dt>
<dd>
<div class="desc"><p>Return checksum protocol use.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def checksum(self):
    &#34;&#34;&#34;Return checksum protocol use.&#34;&#34;&#34;
    return self._checksum</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.gate_logic"><code class="name">var <span class="ident">gate_logic</span></code></dt>
<dd>
<div class="desc"><p>Return gate pull up/down status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gate_logic(self):
    &#34;&#34;&#34;Return gate pull up/down status.&#34;&#34;&#34;
    return self._gate_logic</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.lase"><code class="name">var <span class="ident">lase</span></code></dt>
<dd>
<div class="desc"><p>Return lase state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lase(self):
    &#34;&#34;&#34;Return lase state.&#34;&#34;&#34;
    return self._lase</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.lase_on_power_up"><code class="name">var <span class="ident">lase_on_power_up</span></code></dt>
<dd>
<div class="desc"><p>Return lase on power-up status.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lase_on_power_up(self):
    &#34;&#34;&#34;Return lase on power-up status.&#34;&#34;&#34;
    return self._lase_on_power_up</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.max_power"><code class="name">var <span class="ident">max_power</span></code></dt>
<dd>
<div class="desc"><p>Return estimated maximum output optical power of the laser based on the model and the max_pwm setting in Watts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_power(self):
    &#34;&#34;&#34;Return estimated maximum output optical power of the laser based on the model and the max_pwm setting in Watts.&#34;&#34;&#34;
    est_max_power = self.model * self.max_pwm / 100
    return est_max_power</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.max_pwm"><code class="name">var <span class="ident">max_pwm</span></code></dt>
<dd>
<div class="desc"><p>Return the maximum PWM perentage or maximum duty cycle time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_pwm(self):
    &#34;&#34;&#34;Return the maximum PWM perentage or maximum duty cycle time.&#34;&#34;&#34;
    return self._max_pwm</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.mode"><code class="name">var <span class="ident">mode</span></code></dt>
<dd>
<div class="desc"><p>Return UC-2000 operating mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mode(self):
    &#34;&#34;&#34;Return UC-2000 operating mode.&#34;&#34;&#34;
    return self._mode</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.percent"><code class="name">var <span class="ident">percent</span></code></dt>
<dd>
<div class="desc"><p>Return laser percent, representing the PWM signal duty cycle percentage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def percent(self):
    &#34;&#34;&#34;Return laser percent, representing the PWM signal duty cycle percentage.&#34;&#34;&#34;
    return self._percent</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.power"><code class="name">var <span class="ident">power</span></code></dt>
<dd>
<div class="desc"><p>Return current estimated output optical power of the laser in Watts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def power(self):
    &#34;&#34;&#34;Return current estimated output optical power of the laser in Watts.&#34;&#34;&#34;
    return self.model * self.percent / 100</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.pwm_freq"><code class="name">var <span class="ident">pwm_freq</span></code></dt>
<dd>
<div class="desc"><p>Return laser PWM frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pwm_freq(self):
    &#34;&#34;&#34;Return laser PWM frequency.&#34;&#34;&#34;
    return self._pwm_freq</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uc2000.UC2000Controller.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset all UC-2000 settings to default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset all UC-2000 settings to default.&#34;&#34;&#34;
    # TODO: have reset flag such that it forces all the bottom changes
    self.pwm_freq = self._default[&#34;pwm_freq&#34;]
    self.gate_logic = self._default[&#34;gate_logic&#34;]
    self.max_pwm = self._default[&#34;max_pwm&#34;]
    self.lase_on_power_up = self._default[&#34;lase_on_power_up&#34;]

    self.mode = self._default[&#34;mode&#34;]
    self.lase = self._default[&#34;lase&#34;]
    self.percent = self._default[&#34;percent&#34;]    # in percent</code></pre>
</details>
</dd>
<dt id="uc2000.UC2000Controller.shoot"><code class="name flex">
<span>def <span class="ident">shoot</span></span>(<span>self, shot_percent:Â float, shot_time:Â float, num_shots:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>Shoots a laser shot by using PWM percent sequence of LOW, HIGH, LOW.</p>
<p>Currently, the low laser percent is 3% as this doesn't affect the
silica glass rods we are using, however, the option can be set in the
script above.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>shot_percent</code></strong> :&ensp;<code>float</code></dt>
<dd>PWM laser percent.</dd>
<dt><strong><code>shot_time</code></strong> :&ensp;<code>float</code></dt>
<dd>Time of shot in ms.</dd>
<dt><strong><code>num_shots</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of consecutive shots.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dict containing average interval time, total time, and any response
from UC-2000.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Shot time can be guaranteed but time between shots might be less
accurate.</p>
<p>If shooting more than once, the time between shots is the same time as
the shot time.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; laser = UC2000Controller(model=25)
&gt;&gt;&gt; with laser:
...     laser.shoot(10, 500, 2)
</code></pre>
<p>Fires 2 shots for 500ms at 10% PWM duty cycle percent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shoot(self, shot_percent: float, shot_time: float, num_shots: int):
    &#34;&#34;&#34;
    Shoots a laser shot by using PWM percent sequence of LOW, HIGH, LOW.

    Currently, the low laser percent is 3% as this doesn&#39;t affect the
    silica glass rods we are using, however, the option can be set in the
    script above.

    Parameters
    ----------
    shot_percent : float
        PWM laser percent.
    shot_time : float
        Time of shot in ms.
    num_shots : int
        Number of consecutive shots.

    Returns
    -------
    dict
        Dict containing average interval time, total time, and any response
        from UC-2000.

    Notes
    -----
    Shot time can be guaranteed but time between shots might be less
    accurate.

    If shooting more than once, the time between shots is the same time as
    the shot time.

    Examples
    --------
    &gt;&gt;&gt; laser = UC2000Controller(model=25)
    &gt;&gt;&gt; with laser:
    ...     laser.shoot(10, 500, 2)

    Fires 2 shots for 500ms at 10% PWM duty cycle percent.
    &#34;&#34;&#34;
    shot_time = self._shot_time_limits(shot_time)
    # Convert shot_time to microseconds

    # operations inside the interval.. Labjack interval ensures that the
    # percent should be this for the selected shot_time
    def ops_inside(idx):
        if idx % 2 == 0:
            self.percent = shot_percent
        elif idx % 2 == 1:
            self.percent = MIN_LASE_PERCENT
        return idx + 1, &#34;&#34;

    # operations outside the interval occur as soon as the host sends the
    # command to Labjack
    def ops_outside(idx):
        self.percent = MIN_LASE_PERCENT
        return idx, &#34;&#34;

    self.percent = MIN_LASE_PERCENT
    self.lase = True
    if self._open_labjack:
        # Interval_number is 2*num_shots - 1 because the operations outside
        # end the shot so need odd number of iterations to ensure correct
        # number of shots
        self._open_labjack.add_interval(int(shot_time*1e3), 2*num_shots - 1)
        with self._open_labjack:
            interval_metrics = self._open_labjack.interval.start_interval(
                operations_inside=ops_inside,
                operations_outside=ops_outside
                )
    else:
        interval_metrics = {}
    self.percent = MIN_LASE_PERCENT
    self.lase = False
    self.shot_time_hist += [shot_time]*num_shots
    return interval_metrics</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#synrad-uc2000-controller">Synrad UC2000 Controller</a><ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#todo">TODO</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="uc2000.MIN_LASE_PERCENT" href="#uc2000.MIN_LASE_PERCENT">MIN_LASE_PERCENT</a></code></li>
<li><code><a title="uc2000.SHOT_TIME_RANGE" href="#uc2000.SHOT_TIME_RANGE">SHOT_TIME_RANGE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uc2000.Message" href="#uc2000.Message">Message</a></code></h4>
<ul class="">
<li><code><a title="uc2000.Message.add_no_carry" href="#uc2000.Message.add_no_carry">add_no_carry</a></code></li>
<li><code><a title="uc2000.Message.checksum" href="#uc2000.Message.checksum">checksum</a></code></li>
<li><code><a title="uc2000.Message.command" href="#uc2000.Message.command">command</a></code></li>
<li><code><a title="uc2000.Message.data" href="#uc2000.Message.data">data</a></code></li>
<li><code><a title="uc2000.Message.message_bytes" href="#uc2000.Message.message_bytes">message_bytes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uc2000.UC2000Controller" href="#uc2000.UC2000Controller">UC2000Controller</a></code></h4>
<ul class="two-column">
<li><code><a title="uc2000.UC2000Controller.checksum" href="#uc2000.UC2000Controller.checksum">checksum</a></code></li>
<li><code><a title="uc2000.UC2000Controller.gate_logic" href="#uc2000.UC2000Controller.gate_logic">gate_logic</a></code></li>
<li><code><a title="uc2000.UC2000Controller.lase" href="#uc2000.UC2000Controller.lase">lase</a></code></li>
<li><code><a title="uc2000.UC2000Controller.lase_on_power_up" href="#uc2000.UC2000Controller.lase_on_power_up">lase_on_power_up</a></code></li>
<li><code><a title="uc2000.UC2000Controller.max_power" href="#uc2000.UC2000Controller.max_power">max_power</a></code></li>
<li><code><a title="uc2000.UC2000Controller.max_pwm" href="#uc2000.UC2000Controller.max_pwm">max_pwm</a></code></li>
<li><code><a title="uc2000.UC2000Controller.mode" href="#uc2000.UC2000Controller.mode">mode</a></code></li>
<li><code><a title="uc2000.UC2000Controller.percent" href="#uc2000.UC2000Controller.percent">percent</a></code></li>
<li><code><a title="uc2000.UC2000Controller.percent_step" href="#uc2000.UC2000Controller.percent_step">percent_step</a></code></li>
<li><code><a title="uc2000.UC2000Controller.power" href="#uc2000.UC2000Controller.power">power</a></code></li>
<li><code><a title="uc2000.UC2000Controller.pwm_freq" href="#uc2000.UC2000Controller.pwm_freq">pwm_freq</a></code></li>
<li><code><a title="uc2000.UC2000Controller.reset" href="#uc2000.UC2000Controller.reset">reset</a></code></li>
<li><code><a title="uc2000.UC2000Controller.shoot" href="#uc2000.UC2000Controller.shoot">shoot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>